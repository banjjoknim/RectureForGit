# Git

![git](https://user-images.githubusercontent.com/68052095/95176217-86834b00-07f7-11eb-82b2-ffabcb918e32.png)

- 컴퓨터 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일들의 작업을 조욜하기 위한 `분산 버전 관리 시스템(Distributed Version Control System)`이다.
- 각각의 개발자가 중앙 서버에 접속하지 않은 상태에서도 코드 작업을 할 수 있다.
- 독립적으로 작업한 다음에 변경사항에 대해서 선택적으로 반영, 유연한 채택이 가능하다.

---
# Git

![staging_area](https://user-images.githubusercontent.com/68052095/95195970-4a111880-0812-11eb-810e-50041b2b855a.png)

**Working Tree**
- 아직 버전으로 만들어지기 전 단계, 순수하게 작업내용만 존재하는 공간입니다.
- 일반적으로 사용자가 파일과 하위 폴더를 만들고 작업내용을 저장하는 공간입니다.
- 정확하게는 작업 폴더에서 `.git` 폴더를 제외한 나머지 부분입니다.

**Staging Area** 
- 우리가 버전으로 만들고 싶은 파일을 선별해서 올려두는 공간입니다. 여기에 올라온 파일들만을 모아서 하나의 버전으로 만들고 `repository`에 넣습니다.

**Repository** 
- 버전이 저장되는 저장소입니다. `.git` 폴더를 repository라 봐도 됩니다.

---
# Git

### 커밋(commit)

`버전을 만드는(제출하는) 행위 또는 버전 그 자체를 뜻합니다.`

- 새로 커밋을 생성하면 그 커밋의 부모는 언제나 이전 커밋입니다.
- 커밋이 생성되면 HEAD는 새로운 커밋으로 갱신됩니다.
- HEAD가 가리키는 브랜치도 HEAD와 함께 새로운 커밋을 가리킵니다.
- 커밋하면 커밋 객체가 생깁니다. 커밋 객체에는 부모 커밋에 대한 참조와 실제 커밋을 구성하는 파일 객체가 들어 있습니다.

---
# Git

### 브랜치(branch)

해석하면 `가지`라는 뜻입니다. `분기점이 되기 전의 상태(조상)와 같은 상태`를 가지지만 `동시에 독립적인 상태`를 가집니다.
마치 `평행세계`와 같다고 보면 됩니다. 하나의 저장소에서 다양한 작업을 수행할 수 있게 해줍니다.

![branch](https://user-images.githubusercontent.com/68052095/95193268-82165c80-080e-11eb-99ba-5de27ee3beee.jpg)

---
# Git

### 브랜치(branch)

- 브랜치는 논리적으로는 어떤 커밋과 그 조상들을 묶어서 뜻하지만, 사실은 단순히 커밋 객체 하나를 가리킬 뿐입니다.  

- **HEAD**
  - HEAD는 특수한 포인터입니다. 이 포인터는 지금 작업하는 로컬 브랜치를 가리킵니다.
  - 브랜치는 커밋을 가리키므로 HEAD도 커밋을 가리킵니다.
  - 결국 HEAD는 현재 작업 중인 브랜치의 최근 커밋을 가리킵니다.


- **브랜치를 주로 사용할 때**

  - 새로운 기능 추가
  - 버그 수정
  - 병합(merge)과 리베이스(rebase) 테스트
  - 이전 코드 개선
  - 특정 커밋으로 돌아가고 싶을 때
  
---
# Git

### 태그(tag)

- 주석 있는 태그(권장)
- 간단한 태그
- 커밋에 붙여주는 식별자(이름)
- 커밋을 식별할 수 있는 정보
- ex) `v.1.0.0`

프로그램을 출시하는 것을 **`릴리즈(release)`**라고 하는데, 이때, 태그를 붙여서  사용자들이 쓸 수 있도록 배포하는 것을 말합니다.
태그를 사용하면 **`GitHub`**의 **`[Tags]`** 탭에서 확인할 수 있고, **`[Release]`** 탭에서 다운받을 수도 있습니다.

---
# Git

### 알아둘 것
  - `git`을 이용해서 `한 번이라도 버전관리를 하면` git은 버전관리를 했던 파일을 기억하고 관리대상으로 추가합니다.
  - `git init`을 하지 않으면 git은 그 파일을 관리하지 않습니다. **즉, 자동으로 모든 파일을 관리하지 않습니다.**
  - `HEAD가 가리키는 버전`을 바꿈으로써 우리가 현재 주시하고 있는 디렉토리가 바뀐 버전이 만들어진 시점으로 휙 돌아가게 됩니다.
  - 버전관리를 하지 말아야할 파일이 있다면? `.gitignore`라는 파일을 만들고 버전관리에서 제외할 대상인 파일의 이름을 쓰면됩니다.
---
# GitHub

**Git으로 관리하는 프로젝트를 올릴 수 있는 호스팅 사이트중 하나입니다.**

![github](https://user-images.githubusercontent.com/68052095/95195588-b9d2d380-0811-11eb-9a62-60747e6643f3.jpeg)

---
# GitHub

### 대표적인 Git 호스팅 사이트

| Git 호스팅 사이트   |      특징      |  가격 정책 |
|----------|:-------------:|:------:|
| GitHub.com |  사용자 2,800만 명. 세계 최대 규모의 Git 호스팅 사이트 | 공개저장소 생성 무료, 비공개저장소는 작업자 3인 이하인 경우에는 무료. 설치형 버전인 Enterprise를 월 21달러에 이용할 수 있다. |
| GitLab.com |    GitHub에 뒤지지 않는다. NASA, Sony 등 10만 개 이상의 조직이 사용하고 있다. GitLab 프로젝트 자체가 오픈소스여서 직접 서비스 발전에 기여할 수 있다.   |   공개저장소 및 비공개저장소 생성 무료. 소스코드 빌드에 유용한 도구 지원 성능에 따라 월 4달러 ~ 99달러 부담 |
| BitButcket.org | 사용자 600만 명. 이슈 관리 시스템인 지라(Jira)를 만든 Atlassian이 모기업이어서 지라와 연동이 쉽다. |    5명 이하 팀이면 공개저장소 및 비공개저장소 생성 무료. 그 이상이면 월 2달러 ~ 5달러 부담 |

---
# GitHub

### 알아둘 것

- GitHub에 소스코드를 올려두면 시간, 공간의 제약 없이 협업할 수 있습니다.

- 개인의 컴퓨터에 존재하는 디렉토리에서 `git init` 명령으로 생성되는 `.git` 폴더가 `로컬저장소`입니다. 커밋, 커밋을 구성하는 객체, 스테이지가 모두 이 폴더에 저장됩니다.

- 로컬저장소를 업로드하는 공간을 `원격저장소`라고 부릅니다. 여기서는 `GitHub 저장소`가 곧 `원격저장소`입니다.

- 로컬저장소와 원격저장소는 각각 영어로 `Local Repository`, `Remote Repository`라 합니다.

- 각각의 저장소는 Git으로 관리한 소스코드에 대한 버전정보를 담고 있고, 관리할 수 있습니다.

---
# GitHub

### Git-GitHub의 기본적인 작업흐름도
![basic-remote-workflow](https://user-images.githubusercontent.com/68052095/95196558-34502300-0813-11eb-8139-3975ca11975c.png)

---
# GitHub

### fork

브랜치가 `평행세계`를 만드는 것이었다면, `fork`는 `평행우주`를 만드는 것과 같습니다. `독립된 주소`를 가진 원격저장소를 생성합니다.
  
`fork`는 다른 원격저장소의 `브랜치를 포함한 모든 커밋 이력`을 `새로운 원격저장소`로 복사합니다.
  
![fork2](https://user-images.githubusercontent.com/68052095/95202053-c2c8a280-081b-11eb-91d0-bfb8be415308.png)

---
# GitHub

### `branch` vs `fork`
  
|      |     의의   |      편리한 점      |  불편한 점 |
|------|:----------:|:-------------------:|:----------:|
|`브랜치(branch)`| 하나의 원본저장소에서 분기를 나눈다. |  하나의 원본저장소에서 코드 커밋 이력을 편하게 볼 수 있다. | 다수의 사용자가 다수의 브랜치를 만들면 관리하기 힘들다. |
|`포크(fork)`  | 여러 원격저장소를 만들어 분기를 나눈다. |    원본저장소에 영향을 미치지 않으므로 원격저장소에서 마음껏 코드를 수정할 수 있다.   |   원본저장소의 이력을 보려면 따로 주소를 추가해야 한다. |

---
# GitHub

### fork

GitHub에서 `fork`를 하는 방법은 간단합니다. 원본저장소에 들어간 뒤, 우측 상단의 `fork`버튼을 누르면 됩니다.

![fork](https://user-images.githubusercontent.com/68052095/95200611-a75c9800-0819-11eb-93b8-fb7f2d1aad40.PNG)

---
# GitHub

### Pull Request

`Pull Request`는 어떤 브랜치에 또다른 브랜치를 합치려고 할때, 협력자에게 `브랜치 병합을 요청`하는 메시지를 보내는 것입니다.
즉, `코드에 대한 검토요청`을 하는 것입니다.

![pull_request](https://user-images.githubusercontent.com/68052095/95202375-323e9200-081c-11eb-899e-0a38abe25f07.png)

---
# GitHub

### Pull Request

1. 브랜치의 변경사항 원격저장소에 적용한 뒤, `pull request` 버튼 또는 `Compare & pull request` 버튼을 누릅니다.

![pull_request2](https://user-images.githubusercontent.com/68052095/95204583-43d56900-081f-11eb-82cc-74f654df207f.png)

---
# GitHub

### Pull Request

2. 다음과 같이 `pull request`를 작성하는 창이 나오고 작성해주시면 됩니다.

![pull_request3](https://user-images.githubusercontent.com/68052095/95204594-459f2c80-081f-11eb-8158-9b0fcf7d0d4f.png)

**`base : master`** : 병합된 커밋이 들어갈 브랜치가 `master`라는 뜻입니다.

**`compare : new`** : 병합의 대상이 될 브랜치가 `new`라는 뜻입니다.

---
# GitHub

### Pull Request

3. 마지막으로 검토가 끝난뒤 `Merge pull request` 버튼을 눌러 브랜치를 병합합니다.

![pull_request4](https://user-images.githubusercontent.com/68052095/95206856-2786fb80-0822-11eb-96c7-3a08d70a04bc.png)

---